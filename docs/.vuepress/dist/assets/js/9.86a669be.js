(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{213:function(t,s,a){t.exports=a.p+"assets/img/1558860174985.74dc47fe.png"},214:function(t,s,a){t.exports=a.p+"assets/img/1558860196664.8dfb2629.png"},215:function(t,s,a){t.exports=a.p+"assets/img/1558860253735.85bddbb7.png"},216:function(t,s,a){t.exports=a.p+"assets/img/1558860307470.a593a11d.png"},217:function(t,s,a){t.exports=a.p+"assets/img/1558860334379.5ebab281.png"},218:function(t,s,a){t.exports=a.p+"assets/img/1558860442281.ba9a1ec7.png"},315:function(t,s,a){"use strict";a.r(s);var r=[function(){var t=this,s=t.$createElement,r=t._self._c||s;return r("div",{staticClass:"content"},[r("h2",{attrs:{id:"一、什么是闭包"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#一、什么是闭包","aria-hidden":"true"}},[t._v("#")]),t._v(" 一、什么是闭包")]),t._v(" "),r("p",[t._v("闭包，官方对闭包的解释是：一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。闭包的特点：\n　　1. 作为一个函数变量的一个引用，当函数返回时，其处于激活状态。\n　　2. 一个闭包就是当一个函数返回时，一个没有释放资源的栈区。\n　　"),r("strong",[t._v("简单的说，Javascript允许使用内部函数---即函数定义和函数表达式位于另一个函数的函数体内。而且，这些内部函数可以访问它们所在的外部函数中声明的所有局部变量、参数和声明的其他内部函数。当其中一个这样的内部函数在包含它们的外部函数之外被调用时，就会形成闭包。")])]),t._v(" "),r("div",{staticClass:"tip custom-block"},[r("p",{staticClass:"custom-block-title"},[t._v("我们首先知道闭包有3个特性：")]),t._v(" "),r("p",[r("strong",[t._v("①函数嵌套函数")])]),t._v(" "),r("p",[r("strong",[t._v("②函数内部可以引用函数外部的参数和变量")])]),t._v(" "),r("p",[r("strong",[t._v("③参数和变量不会被垃圾回收机制回收")])])]),t._v(" "),r("h2",{attrs:{id:"二、闭包两种的主要形式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#二、闭包两种的主要形式","aria-hidden":"true"}},[t._v("#")]),t._v(" 二、闭包两种的主要形式")]),t._v(" "),r("h3",{attrs:{id:"①函数作为返回值"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#①函数作为返回值","aria-hidden":"true"}},[t._v("#")]),t._v(" "),r("strong",[t._v("①函数作为返回值")])]),t._v(" "),r("p",[r("img",{attrs:{src:a(213),alt:"1558860174985"}})]),t._v(" "),r("p",[t._v("在这段代码中，a()中的返回值是一个匿名函数，这个函数在a()作用域内部，所以它可以获取a()作用域下变量name的值，将这个值作为返回值赋给全局作用域下的变量b,实现了在全局变量下获取到局部变量中的变量的值")]),t._v(" "),r("p",[t._v("再来看一个闭包的经典例子")]),t._v(" "),r("p",[r("img",{attrs:{src:a(214),alt:"1558860196664"}})]),t._v(" "),r("p",[t._v("一般情况下，在函数fn执行完后，就应该连同它里面的变量一同被销毁，但是在这个例子中，匿名函数作为fn的返回值被赋值给了fn1，这时候相当于fn1=function(){var n = 0 ... }，并且"),r("strong",[t._v("匿名函数内部引用着fn里的变量num，所以变量num无法被销毁，而变量n是每次被调用时新创建的")]),t._v("，所以每次fn1执行完后它就把属于自己的变量连同自己一起销毁，于是乎最后就剩下孤零零的num，于是这里就产生了"),r("strong",[t._v("内存消耗")]),t._v("的问题。")]),t._v(" "),r("p",[r("strong",[t._v("再来看一个经典例子-定时器与闭包")])]),t._v(" "),r("p",[t._v("写一个for循环，让它按顺序打印出当前循环次数")]),t._v(" "),r("p",[r("img",{attrs:{src:a(215),alt:"1558860253735"}})]),t._v(" "),r("p",[t._v("按照预期它应该依次输出1 2 3 4 5，而结果它输出了五次5，这是为什么呢？原来由于js是单线程的，所以在执行for循环的时候"),r("strong",[t._v("定时器setTimeout被安排到任务队列中排队等待执行")]),t._v("，而在等待过程中for循环就已经在执行，等到setTimeout可以执行的时候，for循环已经结束，i的值也已经编程5，所以打印出来五个5，那么我们为了实现预期结果应该怎么改这段代码呢？（ps:如果把for循环里面的var变成let，也能实现预期结果）")]),t._v(" "),r("p",[r("img",{attrs:{src:a(216),alt:"1558860307470"}})]),t._v(" "),r("p",[r("strong",[t._v("引入闭包来保存变量i")]),t._v("，将setTimeout放入立即执行函数中，将for循环中的循环值i作为参数传递，100毫秒后同时打印出1 2 3 4 5")]),t._v(" "),r("p",[t._v("那如果我们想实现每隔100毫秒分别依次输出数字，又该怎么改呢?")]),t._v(" "),r("p",[r("img",{attrs:{src:a(217),alt:"1558860334379"}})]),t._v(" "),r("p",[t._v("在这段代码中，相当于同时启动3个定时器，i*100是为4个定时器分别设置了不同的时间，同时启动，但是执行时间不同，每个定时器间隔都是100毫秒，实现了每隔100毫秒就执行一次打印的效果。")]),t._v(" "),r("h3",{attrs:{id:"②闭包作为参数传递"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#②闭包作为参数传递","aria-hidden":"true"}},[t._v("#")]),t._v(" "),r("strong",[t._v("②闭包作为参数传递")])]),t._v(" "),r("p",[r("img",{attrs:{src:a(218),alt:"1558860442281"}})]),t._v(" "),r("p",[t._v("在这段代码中，函数fn1作为参数传入立即执行函数中，在执行到fn2(30)的时候，30作为参数传入fn1中，这时候if(x>num)中的num取的并不是立即执行函数中的num，而是取创建函数的作用域中的num这里函数创建的作用域是全局作用域下，所以num取的是全局作用域中的值15，即30>15，打印30")]),t._v(" "),r("h2",{attrs:{id:"三、闭包的好处与坏处"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#三、闭包的好处与坏处","aria-hidden":"true"}},[t._v("#")]),t._v(" 三、闭包的好处与坏处")]),t._v(" "),r("h3",{attrs:{id:"好处"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#好处","aria-hidden":"true"}},[t._v("#")]),t._v(" 好处")]),t._v(" "),r("p",[t._v("①保护函数内的变量安全 ，实现封装，防止变量流入其他环境发生命名冲突")]),t._v(" "),r("p",[t._v("②在内存中维持一个变量，可以做缓存（但使用多了同时也是一项缺点，消耗内存）")]),t._v(" "),r("p",[t._v("③匿名自执行函数可以减少内存消耗")]),t._v(" "),r("h3",{attrs:{id:"坏处"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#坏处","aria-hidden":"true"}},[t._v("#")]),t._v(" 坏处")]),t._v(" "),r("p",[t._v("①其中一点上面已经有体现了，就是被引用的私有变量不能被销毁，增大了内存消耗，造成内存泄漏，解决方法是可以在使用完变量后手动为它赋值为null；")]),t._v(" "),r("p",[t._v("②其次由于闭包涉及跨域访问，所以会导致性能损失，我们可以通过把跨作用域变量存储在局部变量中，然后直接访问局部变量，来减轻对执行速度的影响")]),t._v(" "),r("p",[t._v("作者：dovlie\n来源：CSDN\n原文：https://blog.csdn.net/dovlie/article/details/76339244")])])}],n=a(0),v=Object(n.a)({},function(){this.$createElement;this._self._c;return this._m(0)},r,!1,null,null,null);s.default=v.exports}}]);