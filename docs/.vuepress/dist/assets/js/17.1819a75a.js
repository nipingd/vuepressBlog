(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{193:function(e,s,a){e.exports=a.p+"assets/img/1558968775682.3a0755d2.png"},264:function(e,s,a){"use strict";a.r(s);var r=[function(){var e=this,s=e.$createElement,r=e._self._c||s;return r("div",{staticClass:"content"},[r("h2",{attrs:{id:"node-初识"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#node-初识","aria-hidden":"true"}},[e._v("#")]),e._v(" node 初识")]),e._v(" "),r("h3",{attrs:{id:"node-是什么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#node-是什么","aria-hidden":"true"}},[e._v("#")]),e._v(" node 是什么")]),e._v(" "),r("p",[e._v("首先 node 不是一门后台语言而是一个环境，一个能够让 js 运行在服务器的环境，这个环境就好比是服务器上的浏览器（虽然不是很恰当），但正是因为有了它才使得 js 变成了一门后台语言。")]),e._v(" "),r("h3",{attrs:{id:"node-遵循的规范"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#node-遵循的规范","aria-hidden":"true"}},[e._v("#")]),e._v(" node 遵循的规范")]),e._v(" "),r("p",[e._v("其次 node 遵循的是 CommonJs 规范，什么意思？其实就是规定了导入导出的方式😬，就向下面这样：")]),e._v(" "),r("div",{staticClass:"language- line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("require('./module')\nmodule.exports = {\n    a: 1,\n}\nexports.a = 1;\n复制代码\n")])]),e._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[e._v("1")]),r("br"),r("span",{staticClass:"line-number"},[e._v("2")]),r("br"),r("span",{staticClass:"line-number"},[e._v("3")]),r("br"),r("span",{staticClass:"line-number"},[e._v("4")]),r("br"),r("span",{staticClass:"line-number"},[e._v("5")]),r("br"),r("span",{staticClass:"line-number"},[e._v("6")]),r("br")])]),r("p",[e._v("这就是 node 的规范，用 "),r("code",[e._v("require")]),e._v(" 导入、用 "),r("code",[e._v("module.exports")]),e._v(" 导出。那 node 为什么不支持 ESM（就是用 "),r("code",[e._v("import")]),e._v(" 导入、用 "),r("code",[e._v("export")]),e._v(" 导出）规范呢，因为它出现的比较早，仅此而已，然后一时半会儿还改不过来，以后应就会支持了。另外，我们时常在 webpack 里看到 "),r("code",[e._v("require()")]),e._v(" 字样却没有看见 "),r("code",[e._v("import()")]),e._v(" 就是因为 webpack 是要用 node 来执行的，而 node 目前只支持 "),r("code",[e._v("require()")]),e._v("。\n这里顺带来一张各种规范图（这种东西容易忘，当作历史看看就行🙄），如下：")]),e._v(" "),r("p",[r("img",{attrs:{src:a(193),alt:"1558968775682"}})]),e._v(" "),r("h3",{attrs:{id:"require-寻找依赖"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#require-寻找依赖","aria-hidden":"true"}},[e._v("#")]),e._v(" require 寻找依赖")]),e._v(" "),r("p",[r("code",[e._v("require()")]),e._v(" 里面的参数有两种写法，一种带路径一种不带路径。就像下面这样：")]),e._v(" "),r("div",{staticClass:"language- line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("require('./module'); // 带相对路径\nrequire('/module'); // 带绝对路径\nrequire('module'); // 不带路径\n复制代码\n")])]),e._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[e._v("1")]),r("br"),r("span",{staticClass:"line-number"},[e._v("2")]),r("br"),r("span",{staticClass:"line-number"},[e._v("3")]),r("br"),r("span",{staticClass:"line-number"},[e._v("4")]),r("br")])]),r("p",[e._v("这种不带路径的 "),r("code",[e._v("require('module')")]),e._v(" 引入方式，可能是内置模块，也可能是第三方模块，内置模块优先查找，没有的话就是第三方模块了，它会先从当前目录的 "),r("code",[e._v("node_modules")]),e._v(" 里面查找，没有的话就到父目录下的 "),r("code",[e._v("node_modules")]),e._v(" 里面去找，如此向上追溯，直到根目录下的 "),r("code",[e._v("node_modules")]),e._v(" 目录，要是还没有的话就会到全局里面去找，大概是这么一个搜索过程。\n另外一种带路径的方式，就会沿着路径去找，如果没有找到则会尝试将当前目录作一个包来加载。此外，使用绝对路径的速度查找最快，当然了，node 也对路径查找做了缓存机制。")])])}],n=a(0),t=Object(n.a)({},function(){this.$createElement;this._self._c;return this._m(0)},r,!1,null,null,null);s.default=t.exports}}]);